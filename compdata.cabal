Name:			compdata
Version:		0.1
Synopsis:            	Compositional Data Types
Description:

  Based on Wouter Swierstra's Functional Pearl /Data types à la carte/,
  this package provides a framework for defining recursive
  data types in a compositional manner. Fundamental idea of
  compositional data types is to separate the signature of a data type
  from the fixed point construction that constructs its recursive
  structure. By allowing to compose and decompose signatures,
  /compositional data types/ enable to combine data types in a flexible
  way. The key point of Wouter Swierstra's original work is to define
  functions on /compositional data types/ in a compositional manner as
  well by leveraging Haskell's type class machinery.
  .
  Building on this foundation, this library provides additional
  extensions and (run-time) optimisations which makes /compositional data types/
  applicable for practical applications. In particular, it
  provides an excellent framework for manipulating and analysing
  abstract syntax trees in a type safe manner. Thus, it is perfectly
  suited for compiler construction, especially, in an environment
  consisting of a family of tightly interwoven /domain-specific languages/.
  .
  In concrete terms, this package provides the following features:
  .
  *  Compositional data types in the style of Wouter Swierstra's
     Functional Pearl /Data types à la carte/.
  .
  *  Modular definition of function on compositional data types through
     catamorphisms and anamorphisms as well as more structured
     recursion schemes such as primitive recursion  and co-recursion,
     and course-of-value iteration and co-iteration.
  .
  *  Support for monadic computations via monadic variants of all
     recursion schemes.
  .
  *  Support for convenient programming over compositional data types
     via generic programming combinators that allow various forms of
     generic transformations and generic queries.
  .
  *  Generalisation of compositional data types (terms) to
     compositional data types \"with holes\" (contexts). This allows
     flexible reuse of a wide variety of catamorphisms as well as
     efficient composition of them.
  .
  *  Operations on signatures to, for example, add and remove
     annotations of abstract syntax trees. This includes combinators to
     propagate annotations fully automatically through certain
     catamorphisms.
  .
  *  Optimisation of the implementation of recursion schemes. This
     includes /short-cut fusion/ style optimisation rules which yield a
     performance boost of up to factor six.
  .
  *  Efficient implementation of catamorphisms on non-polynomial
     signatures that contain function types. This allows to represent
     /higher-order abstract syntax/ with compositional data types.
  .
  *  Automatic derivation of instances of all relevant type classes for
     using compositional data types via /Template Haskell/. This includes
     instances of 'Prelude.Eq', 'Prelude.Ord' and 'Prelude.Show' that are
     derived via instances for functorial variants of them. Additionally,
     also /smart constructors/, which allow to easily construct inhabitants
     of compositional data types, are automatically generated.
  .
  *  /Mutually recursive data types/. All of the above is also lifted to
     families of mutually recursive data types.
  .
  For examples illustrating the use of compositional data types, consult
  "Data.Comp" resp. "Data.Comp.Multi" for mutually recursive data types.

Category:            	Data
License:		BSD3
License-file:		LICENSE
Author:			Patrick Bahr, Tom Hvitved
Maintainer:		paba@diku.dk
Build-Type:		Custom
Cabal-Version:          >=1.8.0.6

flag test
  description: Build test executable.
  default:     False

flag benchmark
  description: Build benchmark executable.
  default:     False

library
  Exposed-Modules:      Data.Comp, Data.Comp.Product, Data.Comp.Sum,
                        Data.Comp.Term, Data.Comp.Algebra, Data.Comp.Equality,
                        Data.Comp.Ordering, Data.Comp.DeepSeq, Data.Comp.Generic
                        Data.Comp.TermRewriting, Data.Comp.Automata,
                        Data.Comp.Arbitrary, Data.Comp.Show, Data.Comp.Variables,
                        Data.Comp.Decompose, Data.Comp.Unification,
                        Data.Comp.Derive, Data.Comp.Matching, Data.Comp.Multi,
                        Data.Comp.Multi.Term, Data.Comp.Multi.Sum,
                        Data.Comp.Multi.HFunctor, Data.Comp.Multi.HExpFunctor,
                        Data.Comp.Multi.Algebra,
                        Data.Comp.Multi.Product, Data.Comp.Multi.HShow,
                        Data.Comp.Multi.HEquality, Data.Comp.Multi.Variables,
                        Data.Comp.Multi.Ops, Data.Comp.Ops, Data.Comp.ExpFunctor

  Other-Modules:        Data.Comp.Derive.Utils, Data.Comp.Derive.Equality,
                        Data.Comp.Derive.Ordering, Data.Comp.Derive.Arbitrary,
                        Data.Comp.Derive.Show, Data.Comp.Derive.DeepSeq,
                        Data.Comp.Derive.SmartConstructors, Data.Comp.Derive.Foldable,
                        Data.Comp.Derive.Traversable, Data.Comp.Derive.HFunctor,
                        Data.Comp.Derive.HFoldable, Data.Comp.Derive.HTraversable,
                        Data.Comp.Derive.HEquality, Data.Comp.Derive.HShow,
                        Data.Comp.Derive.ExpFunctor, Data.Comp.Derive.HExpFunctor,

                        Data.Comp.Derive.SmartMConstructors

  Build-Depends:	base >= 4, template-haskell, containers, mtl, QuickCheck >= 2, derive, deepseq, th-expand-syns
  hs-source-dirs:	src
  ghc-options:          -W -O2
  if flag(benchmark)
    buildable:     False

Executable test
  Main-is:		Data_Test.hs
  Build-Depends:	base >= 4, template-haskell, containers, mtl, QuickCheck >= 2, test-framework, test-framework-quickcheck2, derive, th-expand-syns
  hs-source-dirs:	src testsuite/tests
  ghc-options:          -fhpc
  if !flag(test)
    buildable:     False

Executable benchmark
  Main-is:		Benchmark.hs
  Build-Depends:	base >= 4, template-haskell, containers, mtl, QuickCheck >= 2, derive, deepseq, criterion, random, uniplate, th-expand-syns
  hs-source-dirs:	src benchmark
  ghc-options:          -W -O2
  cpp-options:          -DNO_RULES
  if !flag(benchmark)
    buildable:     False